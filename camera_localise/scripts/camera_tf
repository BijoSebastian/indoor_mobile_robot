#!/usr/bin/env python

import rospy
import rospkg
import tf
from tf.transformations import quaternion_from_euler
import numpy as np
import yaml
import io

from geometry_msgs.msg import TransformStamped
from apriltag_ros.msg import AprilTagDetectionArray
from geometry_msgs.msg import PoseWithCovarianceStamped

class FindRobot():
	def __init__(self):
		self.robotpose = None
		self.position_camera = None
		self.quaternion_camera = None
		self.published = False

	@staticmethod	
	def get_tag_tf(msg):
		current = rospy.Time.now()
		T = {}
		listener = tf.TransformListener()
		for det in msg.detections:
			tag_str = 'tag_'+str(det.id[0])
			listener.waitForTransform(tag_str,'camera',rospy.Time(), rospy.Duration(1.0))
			(trans,rot) = listener.lookupTransform(tag_str,'camera',rospy.Time())
			T[det.id[0]] = listener.fromTranslationRotation(trans, rot)
					
		return T
	
	@staticmethod
	def get_tag_world():
		tags_dict = {}
		rospack = rospkg.RosPack()
		base_path = rospack.get_path('camera_localise')
		with open(base_path+"/config/tag_pos.yaml", 'r') as stream:
			tags = yaml.safe_load(stream)
			tags = tags['standalone_tags']
			for i in tags:
				tags_dict[i['id']] = tf.transformations.compose_matrix(angles=(i['ex'],i['ey'],i['ez']),translate=(i['x'],i['y'],i['z']))
			
		return tags_dict
	
	@staticmethod
	def get_camera_tf(tags_dict,T_dict):
		tlist = []
		for key in T_dict.keys():
			tlist.append(np.matmul(tags_dict[key],T_dict[key]))
		T = sum(tlist)/len(tlist)
		quat = tf.transformations.quaternion_from_matrix(T)
		pos = tuple(T[0:3,3])
		return pos,quat
	

	def send_camera_pose(self,msg):
		tags = self.get_tag_world()
		q_rc = tf.transformations.quaternion_from_euler(0,-1.5708,-1.5708)

		try:
			T = self.get_tag_tf(msg)
			self.published = True
			self.robotpose = PoseWithCovarianceStamped()
			self.position_camera, self.quaternion_camera = self.get_camera_tf(tags,T)
			q_wr = tf.transformations.quaternion_multiply(self.quaternion_camera,q_rc)
			self.robotpose.pose.pose.position.x = self.position_camera[0]*1e3
			self.robotpose.pose.pose.position.y = self.position_camera[1]*1e3
			self.robotpose.pose.pose.position.z = self.position_camera[2]*1e3
			self.robotpose.pose.pose.orientation.x = q_wr[0]
			self.robotpose.pose.pose.orientation.y = q_wr[1]
			self.robotpose.pose.pose.orientation.z = q_wr[2]
			self.robotpose.pose.pose.orientation.w = q_wr[3]
			self.robotpose.pose.covariance = [500,0,0,0,0,50,\
																	0,50,0,0,0,10,\
																	0,0,0,0,0,0,\
																	0,0,0,0,0,0,\
																	0,0,0,0,0,0,\
																	50,10,0,0,0,500]		
		except:
			self.published = False
	
	
if __name__ == '__main__':
	rospy.init_node('camera_localise_node')
	detection = FindRobot()
	rospy.Subscriber("/tag_detections",AprilTagDetectionArray,detection.send_camera_pose)
	pub = rospy.Publisher('/aprtag',PoseWithCovarianceStamped,queue_size=1)
	br = tf.TransformBroadcaster()
	R = rospy.Rate(10)
	while not rospy.is_shutdown():
		if detection.published:
			br.sendTransform(detection.position_camera,detection.quaternion_camera,rospy.Time.now(),"camera","world")
			pub.publish(detection.robotpose)
		R.sleep()
	# rospy.spin()
	
